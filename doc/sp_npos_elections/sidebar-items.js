initSidebarItems({"enum":[["Error","The errors that might occur in the this crate and compact."]],"fn":[["assignment_ratio_to_staked","Converts a vector of ratio assignments into ones with absolute budget value."],["assignment_ratio_to_staked_normalized","Same as [`assignment_ratio_to_staked`] and try and do normalization."],["assignment_staked_to_ratio","Converts a vector of staked assignments into ones with ratio values."],["assignment_staked_to_ratio_normalized","Same as [`assignment_staked_to_ratio`] and try and do normalization."],["balance","Balance the weight distribution of a given `voters` at most `iterations` times, or up until the point where the biggest difference created per iteration of all stakes is `tolerance`. If this is called with `tolerance = 0`, then exactly `iterations` rounds will be executed, except if no change has been made (`difference = 0`)."],["build_support_map","Build the support map from the given election result. It maps a flat structure like"],["evaluate_support","Evaluate a support map. The returned tuple contains:"],["is_score_better","Compares two sets of election scores based on desirability and returns true if `this` is better than `that`."],["phragmms","Execute the phragmms method."],["reduce","Reduce the given [`Vec<StakedAssignment<IdentifierT>>`]. This removes redundant edges from without changing the overall backing of any of the elected candidates."],["seq_phragmen","Execute sequential phragmen with potentially some rounds of `balancing`. The return type is list of winners and a weight distribution vector of all voters who contribute to the winners."],["seq_phragmen_core","Core implementation of seq-phragmen."],["to_without_backing","consumes a vector of winners with backing stake to just winners."]],"macro":[["generate_solution_type","Generates a struct to store the election result in a small way. This can encode a structure which is the equivalent of a `sp_npos_elections::Assignment<_>`."]],"struct":[["Assignment","A voter's stake assignment among a set of targets, represented as ratios."],["Candidate","A candidate entity for the election."],["Edge","A vote being casted by a [`Voter`] to a [`Candidate`] is an `Edge`."],["ElectionResult","Final result of the election."],["StakedAssignment","A voter's stake assignment among a set of targets, represented as absolute values in the scale of [`ExtendedBalance`]."],["Support","A structure to demonstrate the election result from the perspective of the candidate, i.e. how much support each candidate is receiving."],["Voter","A voter entity."]],"trait":[["IdentifierT","an aggregator trait for a generic type of a voter/target identifier. This usually maps to substrate's account id."],["VotingLimit","A trait to limit the number of votes per voter. The generated compact type will implement this."]],"type":[["CandidatePtr","A pointer to a candidate struct with interior mutability."],["ElectionScore","The score of an assignment. This can be computed from the support map via [`evaluate_support`]."],["ExtendedBalance","A type in which performing operations on vote weights are safe."],["SupportMap","A linkage from a candidate and its [`Support`]."],["VoteWeight","A type which is used in the API of this crate as a numeric weight of a vote, most often the stake of the voter. It is always converted to [`ExtendedBalance`] for computation."],["WithApprovalOf","A winner, with their respective approval stake."]]});