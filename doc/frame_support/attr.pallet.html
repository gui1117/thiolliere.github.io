<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `pallet` attr in crate `frame_support`."><meta name="keywords" content="rust, rustlang, rust-lang, pallet"><title>frame_support::pallet - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc attr"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../frame_support/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class="location"><a href="index.html">frame_support</a></p><script>window.sidebarCurrent = {name: "pallet", ty: "attr", relpath: ""};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/frame_support_procedural/lib.rs.html#313" title="goto source code">[src]</a></span><span class="in-band">Attribute Macro <a href="index.html">frame_support</a>::<wbr><a class="attr" href="">pallet</a></span></h1><pre class="rust attr">#[pallet]</pre><div class="docblock"><p><code>pallet</code> attribute macro allows to define a pallet to be used in <code>construct_runtime!</code>.</p>
<p>It is define by a module item:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>]</span>
<span class="kw">mod</span> <span class="ident">pallet</span> {
...
}</pre></div>
<p>Inside the module the macro will parse item with the attribute: <code>#[pallet::*]</code>, some attributes
are mandatory, some other optional.</p>
<p>The attribute are explained with the syntax of non instantiable pallets, to see how pallet with
instance work see below example.</p>
<p>Note various type can be automatically imported using pallet_prelude in frame_support and
frame_system:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>]</span>
<span class="kw">mod</span> {
	<span class="kw">use</span> <span class="ident">frame_support</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="ident">frame_system</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>;
	...
}</pre></div>
<h1 id="config-trait-palletconfig-mandatory" class="section-header"><a href="#config-trait-palletconfig-mandatory">Config trait: <code>#[pallet::config]</code> mandatory</a></h1>
<p>The trait defining generics of the pallet.</p>
<p>Item must be defined as</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">config</span>]</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">Config</span>: <span class="ident">frame_system</span>::<span class="ident">Config</span> <span class="op">+</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">optionally_some_other_supertraits</span>
<span class="macro-nonterminal">$</span><span class="macro-nonterminal">optional_where_clause</span>
{
...
}</pre></div>
<p>I.e. a regular trait definition named <code>Config</code>, with supertrait <code>frame_system::Config</code>,
optionally other supertrait and where clause.</p>
<p>The associated type <code>Event</code> is reserved, if defined it must bounds <code>From&lt;Event&gt;</code> and
<code>IsType&lt;&lt;Self as frame_system::Config&gt;::Event&gt;</code>, see <code>#[pallet::event]</code> for more information.</p>
<p>To put <code>Get</code> associated type into metadatas, use the attribute <code>#[pallet::constant]</code>, e.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">config</span>]</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">Config</span>: <span class="ident">frame_system</span>::<span class="ident">Config</span> {
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">constant</span>]</span>
	<span class="kw">type</span> <span class="ident">Foo</span>: <span class="ident">Get</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>;
}</pre></div>
<p>To bypass the <code>frame_system::Config</code> supertrait check, use the attribute
<code>#[pallet::disable_frame_system_supertrait_check]</code>, e.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">config</span>]</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">disable_frame_system_supertrait_check</span>]</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">Config</span>: <span class="ident">pallet_timestamp</span>::<span class="ident">Config</span> {}</pre></div>
<h3 id="macro-expansion" class="section-header"><a href="#macro-expansion">Macro expansion:</a></h3>
<p>The macro expand pallet constant metadata with the information given by <code>#[pallet::constant]</code>.</p>
<h1 id="pallet-struct-placeholder-palletpallet-mandatory" class="section-header"><a href="#pallet-struct-placeholder-palletpallet-mandatory">Pallet struct placeholder: <code>#[pallet::pallet]</code> mandatory</a></h1>
<p>The placeholder struct, on which is implemented pallet informations.</p>
<p>Item must be defined as followed:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">pallet</span>]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);</pre></div>
<p>I.e. a regular struct definition named <code>Pallet</code>, with generic T and no where clause.</p>
<p>To generate a <code>Store</code> trait associating all storages, use the attribute
<code>#[pallet::generate_store($vis trait Store)]</code>, e.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">pallet</span>]</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generate_store</span>(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait</span> <span class="ident">Store</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);</pre></div>
<p>More precisely the store trait contains an associated type for each storage. It is implemented
for <code>Pallet</code> allowing to access the storage from pallet struct.</p>
<h3 id="macro-expansion-1" class="section-header"><a href="#macro-expansion-1">Macro expansion:</a></h3>
<p>The macro add this attribute to the struct definition:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">derive</span>(
	<span class="ident">frame_support</span>::<span class="ident">CloneNoBound</span>,
	<span class="ident">frame_support</span>::<span class="ident">EqNoBound</span>,
	<span class="ident">frame_support</span>::<span class="ident">PartialEqNoBound</span>,
	<span class="ident">frame_support</span>::<span class="ident">RuntimeDebugNoBound</span>,
)]</span></pre></div>
<p>It implements on pallet:</p>
<ul>
<li>[<code>GetPalletVersion</code>]</li>
<li>[<code>OnGenesis</code>]: contains some logic to write pallet version into storage.</li>
<li>[<code>ModuleErrorMetadata</code>]: using error declared or no metadata.</li>
</ul>
<p>If attribute generate_store then macro create the trait <code>Store</code> and implement it on <code>Pallet</code>.</p>
<h1 id="hooks-pallethooks-mandatory" class="section-header"><a href="#hooks-pallethooks-mandatory">Hooks: <code>#[pallet::hooks]</code> mandatory</a></h1>
<p>Implementation of <code>Hooks</code> on <code>Pallet</code> allowing to define some specific pallet logic.</p>
<p>Item must be defined as</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">hooks</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">Hooks</span><span class="op">&lt;</span><span class="ident">BlockNumberFor</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">optional_where_clause</span> {
}</pre></div>
<p>I.e. a regular trait implementation with generic bound: <code>T: Config</code>, for the trait
<code>Hooks&lt;BlockNumberFor&lt;T&gt;&gt;</code> (they are defined in preludes), for the type <code>Pallet&lt;T&gt;</code>
and with an optional where clause.</p>
<h3 id="macro-expansion-2" class="section-header"><a href="#macro-expansion-2">Macro expansion:</a></h3>
<p>The macro implements the traits <code>OnInitialize</code>, <code>OnFinalize</code>, <code>OnRuntimeUpgrade</code>,
<code>OffchainWorker</code>, <code>IntegrityTest</code> using <code>Hooks</code> implementation.</p>
<p>NOTE: OnRuntimeUpgrade is implemented with <code>Hooks::on_runtime_upgrade</code> and some additional
logic. E.g. logic to write pallet version into storage.</p>
<h1 id="call-palletcall-mandatory" class="section-header"><a href="#call-palletcall-mandatory">Call: <code>#[pallet::call]</code> mandatory</a></h1>
<p>Implementation of pallet dispatchables.</p>
<p>Item must be defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">call</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
	<span class="doccomment">/// $some_doc</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">weight</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ExpressionResultingInWeight</span>)]</span>
	<span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span>(
		<span class="ident">origin</span>: <span class="ident">OriginFor</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
		<span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_arg</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_type</span>,
		<span class="comment">// or with compact attribute: #[pallet::compact] $some_arg: $some_type,</span>
		...
	) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">DispatchResultWithPostInfo</span> {
		...
	}
	...
}</pre></div>
<p>I.e. a regular type implementation, with generic <code>T: Config</code>, on type <code>Pallet&lt;T&gt;</code>, with
optional where clause.</p>
<p>Each dispatchable needs to define a weight with <code>#[pallet::weight($expr)]</code> attribute,
the first argument must be <code>origin: OriginFor&lt;T&gt;</code>, compact encoding for argument can be used
using <code>#[pallet::compact]</code>, function must return DispatchResultWithPostInfo.</p>
<p>All arguments must implement <code>Debug</code>, <code>PartialEq</code>, <code>Eq</code>, <code>Decode</code>, <code>Encode</code>, <code>Clone</code>. For ease
of use just bound trait <code>Member</code> available in frame_support::pallet_prelude.</p>
<p><strong>WARNING</strong>: modifying dispatchables, changing their order, removing some must be done with
care. Indeed this will change the outer runtime call type (which is an enum with one variant
per pallet), this outer runtime call can be stored on-chain (e.g. in pallet-scheduler).
Thus migration might be needed.</p>
<h3 id="macro-expansion-3" class="section-header"><a href="#macro-expansion-3">Macro expansion</a></h3>
<p>The macro create an enum <code>Call</code> with one variant per dispatchable. This enum implements:
<code>Clone</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Debug</code> (with stripped implementation in <code>not(&quot;std&quot;)</code>), <code>Encode</code>,
<code>Decode</code>, <code>GetDispatchInfo</code>, <code>GetCallName</code>, <code>UnfilteredDispatchable</code>.</p>
<p>The macro implement on <code>Pallet</code>, the <code>Callable</code> trait and a function <code>call_functions</code> which
returns the dispatchable metadatas.</p>
<h1 id="extra-constants-palletextra_constants-optional" class="section-header"><a href="#extra-constants-palletextra_constants-optional">Extra constants: <code>#[pallet::extra_constants]</code> optional</a></h1>
<p>Allow to define some extra constants to put into constant metadata.</p>
<p>Item must be defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">extra_constants</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">optional_where_clause</span> {
	<span class="doccomment">/// $some_doc</span>
	<span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span> <span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">fn_name</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_return_type</span> {
		...
	}
	...
}</pre></div>
<p>I.e. a regular rust implement block with some optional where clause and functions with 0 args,
0 generics, and some return type.</p>
<h3 id="macro-expansion-4" class="section-header"><a href="#macro-expansion-4">Macro expansion</a></h3>
<p>The macro add some extra constant to pallet constant metadata.</p>
<h1 id="error-palleterror-optional" class="section-header"><a href="#error-palleterror-optional">Error: <code>#[pallet::error]</code> optional</a></h1>
<p>Allow to define an error type to be return from dispatchable on error.
This error type informations are put into metadata.</p>
<p>Item must be defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">error</span>]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Error</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
	<span class="doccomment">/// $some_optional_doc</span>
	<span class="macro-nonterminal">$</span><span class="macro-nonterminal">SomeFieldLessVariant</span>,
	...
}</pre></div>
<p>I.e. a regular rust enum named <code>Error</code>, with generic <code>T</code> and fieldless variants.</p>
<h3 id="macro-expansion-5" class="section-header"><a href="#macro-expansion-5">Macro expansion</a></h3>
<p>The macro implements <code>Debug</code> trait and functions <code>as_u8</code> using variant position, and <code>as_str</code>
using variant doc.</p>
<p>The macro implements <code>From&lt;Error&lt;T&gt;&gt;</code> for <code>&amp;'static str</code>.
The macro implements <code>From&lt;Error&lt;T&gt;&gt;</code> for <code>DispatchError</code>.</p>
<p>The macro implements <code>ModuleErrorMetadata</code> on <code>Pallet</code> defining the <code>ErrorMetadata</code> of the
pallet.</p>
<h1 id="event-palletevent-optional" class="section-header"><a href="#event-palletevent-optional">Event: <code>#[pallet::event]</code> optional</a></h1>
<p>Allow to define pallet events, pallet events are stored in the block when they deposited (and
removed in next block).</p>
<p>Item is defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">event</span>]</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">metadata</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">SomeType</span> <span class="op">=</span> <span class="string">&quot;$Metadata&quot;</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">SomeOtherType</span> <span class="op">=</span> <span class="string">&quot;$Metadata&quot;</span>, ..)]</span> <span class="comment">// Optional</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generate_deposit</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">visbility</span> <span class="kw">fn</span> <span class="ident">deposit_event</span>)]</span> <span class="comment">// Optional</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Event</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_generic</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">optional_where_clause</span> {
	<span class="doccomment">/// Some doc</span>
	<span class="macro-nonterminal">$</span><span class="macro-nonterminal">SomeName</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">SomeType</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">YetanotherType</span>, ...),
	...
}</pre></div>
<p>I.e. an enum (with named or unnamed fields variant), named Event, with generic: none or <code>T</code> or
<code>T: Config</code>, and optional where clause.</p>
<p>Each field must implement <code>Clone</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Encode</code>, <code>Decode</code>, and <code>Debug</code> (on std
only).
For ease of use just bound trait <code>Member</code> available in frame_support::pallet_prelude.</p>
<p>Variant documentations and field types are put into metadata.
The attribute <code>#[pallet::metadata(..)]</code> allows to specify the metadata to put for some types.</p>
<p>The metadat of a type is defined by:</p>
<ul>
<li>if matching a type in <code>#[pallet::metadata(..)]</code>, then the corresponding metadata.</li>
<li>otherwise the last segment of the type.</li>
</ul>
<p>E.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">event</span>]</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">metadata</span>(<span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;SpecialU32&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Event</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> {
	<span class="ident">Proposed</span>(<span class="ident">u32</span>, <span class="ident">T</span>::<span class="ident">AccountId</span>),
}</pre></div>
<p>will write in event variant metadata <code>&quot;SpecialU32&quot;</code> and <code>&quot;AccountId&quot;</code>.</p>
<p>The attribute <code>#[pallet::generate_deposit($visbility fn deposit_event)]</code> generate a helper
function on <code>Pallet</code> to deposit event.</p>
<p>NOTE: For instantiable pallet, event must be generic over T and I.</p>
<h3 id="macro-expansion-6" class="section-header"><a href="#macro-expansion-6">Macro expansion:</a></h3>
<p>Macro will add on enum <code>Event</code> the attributes:</p>
<ul>
<li><code>#[derive(frame_support::CloneNoBound)]</code>,</li>
<li><code>#[derive(frame_support::EqNoBound)]</code>,</li>
<li><code>#[derive(frame_support::PartialEqNoBound)]</code>,</li>
<li><code>#[derive(codec::Encode)]</code>,</li>
<li><code>#[derive(codec::Decode)]</code>,</li>
<li><code>#[derive(frame_support::RuntimeDebugNoBound)]</code></li>
</ul>
<p>Macro implements <code>From&lt;Event&lt;..&gt;&gt;</code> for ().</p>
<p>Macro implements metadata function on <code>Event</code> returning the <code>EventMetadata</code>.</p>
<p>If <code>#[pallet::generate_deposit]</code> then macro implement <code>fn deposit_event</code> on <code>Pallet</code>.</p>
<h1 id="storage-palletstorage-optional" class="section-header"><a href="#storage-palletstorage-optional">Storage: <code>#[pallet::storage]</code> optional</a></h1>
<p>Allow to define some abstract storage inside runtime storage and also set its metadata.
This attribute can be used multiple times.</p>
<p>Item is defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">getter</span>(<span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">getter_name</span>)]</span> <span class="comment">// optional</span>
<span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span> <span class="kw">type</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">StorageName</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_generic</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">optional_where_clause</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">StorageType</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_generics</span>, ...<span class="op">&gt;</span>;</pre></div>
<p>I.e. it must be a type alias, with generics: <code>T</code> or <code>T: Config</code>, aliased type must be one
of <code>StorageValue</code>, <code>StorageMap</code> or <code>StorageDoubleMap</code> (defined in frame_support).
Their first generic must be <code>_</code> as it is written by the macro itself.</p>
<p>The Prefix generic written by the macro is generated using PalletInfo::name and the name of the
storage type.
E.g. if runtime name the pallet MyExample the storage <code>type Foo&lt;T&gt; = ...</code> use
prefixes: <code>Twox128(b&quot;MyExample&quot;) ++ Twox128(b&quot;Foo&quot;)</code>.</p>
<p>The optional attribute <code>#[pallet::getter(fn $my_getter_fn_name)]</code> allow to define a
getter function on <code>Pallet</code>.</p>
<p>E.g:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">getter</span>(<span class="kw">fn</span> <span class="ident">my_storage</span>)]</span>
<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type</span> <span class="ident">MyStorage</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">StorageMap</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">Blake2_128Concat</span>, <span class="ident">u32</span>, <span class="ident">u32</span><span class="op">&gt;</span>;</pre></div>
<p>NOTE: if the querykind generic parameter is still generic at this stage or is using some type
alias then the generation of the getter might fail. In this case getter can be implemented
manually.</p>
<h3 id="macro-expansion-7" class="section-header"><a href="#macro-expansion-7">Macro expansion</a></h3>
<p>For each storage the macro generate a struct named
<code>_GeneratedPrefixForStorage$NameOfStorage</code>, implements StorageInstance on it using pallet
names and storage name. and use it as first generic of the aliased type.</p>
<p>The macro implement the function <code>storage_metadata</code> on <code>Pallet</code> implementing the metadata for
storages.</p>
<h1 id="type-value-pallettype_value-optional" class="section-header"><a href="#type-value-pallettype_value-optional">Type value: <code>#[pallet::type_value]</code> optional</a></h1>
<p>Helper to define a struct implementing <code>Get</code> trait. To ease use of storage types.
This attribute can be used multiple time.</p>
<p>Item is defined as</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">type_value</span>]</span>
<span class="kw">fn</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">MyDefaultName</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">some_generic</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">default_type</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">optional_where_clause</span> { <span class="macro-nonterminal">$</span><span class="macro-nonterminal">expr</span> }</pre></div>
<p>I.e.: a function definition with generics none or <code>T: Config</code> and a returned type.</p>
<p>E.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">type_value</span>]</span>
<span class="kw">fn</span> <span class="ident">MyDefault</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">T</span>::<span class="ident">Balance</span> { <span class="number">3</span>.<span class="ident">into</span>() }</pre></div>
<p>NOTE: This attribute is meant to be used alongside <code>#[pallet::storage]</code> to defined some
specific default value in storage.</p>
<h3 id="macro-expansion-8" class="section-header"><a href="#macro-expansion-8">Macro expansion</a></h3>
<p>Macro generate struct with the name of the function and its generic, and implement
<code>Get&lt;$ReturnType&gt;</code> on it using the provided function block.</p>
<h1 id="genesis-config-palletgenesis_config-optional" class="section-header"><a href="#genesis-config-palletgenesis_config-optional">Genesis config: <code>#[pallet::genesis_config]</code> optional</a></h1>
<p>Allow to define the genesis configuration of the pallet.</p>
<p>Item is defined as either a type alias or an enum or a struct.
It needs to be public and implement trait GenesisBuild with <code>#[pallet::genesis_build]</code>.
The type generics is constrained to be either none, or <code>T</code> or <code>T: Config</code>.</p>
<p>E.g:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_config</span>]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">GenesisConfig</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> {
	<span class="ident">_myfield</span>: <span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
}</pre></div>
<h3 id="macro-expansion-9" class="section-header"><a href="#macro-expansion-9">Macro expansion</a></h3>
<p>Macro will add the following attribute on it:</p>
<ul>
<li><code>#[cfg(feature = &quot;std&quot;)]</code></li>
<li><code>#[derive(Serialize, Deserialize)]</code></li>
<li><code>#[serde(rename_all = &quot;camelCase&quot;)]</code></li>
<li><code>#[serde(deny_unknown_fields)]</code></li>
<li><code>#[serde(bound(serialize = &quot;&quot;))]</code></li>
<li><code>#[serde(bound(deserialize = &quot;&quot;))]</code></li>
</ul>
<h1 id="genesis-build-palletgenesis_build-optional" class="section-header"><a href="#genesis-build-palletgenesis_build-optional">Genesis build: <code>#[pallet::genesis_build]</code> optional</a></h1>
<p>Allow to define how genesis_configuration is built.</p>
<p>Item is defined as</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_build</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">GenesisBuild</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">GenesisConfig</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">maybe_generics</span><span class="op">&gt;</span> {
	<span class="kw">fn</span> <span class="ident">build</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { <span class="macro-nonterminal">$</span><span class="macro-nonterminal">expr</span> }
}</pre></div>
<p>I.e. a rust trait implementation with generic <code>T: Config</code>, of trait <code>GenesisBuild&lt;T&gt;</code> on type
<code>GenesisConfig</code> with generics none or <code>T</code>.</p>
<p>E.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_build</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">GenesisBuild</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">GenesisConfig</span> {
	<span class="kw">fn</span> <span class="ident">build</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {}
}</pre></div>
<h3 id="macro-expansion-10" class="section-header"><a href="#macro-expansion-10">Macro expansion</a></h3>
<p>Macro will add the following attribute on it:</p>
<ul>
<li><code>#[cfg(feature = &quot;std&quot;)]</code></li>
</ul>
<p>Macro will implement <code>sp_runtime::BuildModuleGenesisStorage</code> using <code>()</code> as second generic for
non-instantiable pallets.</p>
<h1 id="inherent-palletinherent-optional" class="section-header"><a href="#inherent-palletinherent-optional">Inherent: <code>#[pallet::inherent]</code> optional</a></h1>
<p>Allow the pallet to provide some inherent:</p>
<p>Item is defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">inherent</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">ProvideInherent</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
	<span class="comment">// ... regular trait implementation</span>
}</pre></div>
<p>I.e. a trait implementation with bound <code>T: Config</code>, of trait <code>ProvideInherent</code> for type
<code>Pallet&lt;T&gt;</code>, and some optional where clause.</p>
<h3 id="macro-expansion-11" class="section-header"><a href="#macro-expansion-11">Macro expansion</a></h3>
<p>Macro make currenlty no use of this information, but it might use this information in the
future to give information directly to construct_runtime.</p>
<h1 id="validate-unsigned-palletvalidate_unsigned-optional" class="section-header"><a href="#validate-unsigned-palletvalidate_unsigned-optional">Validate unsigned: <code>#[pallet::validate_unsigned]</code> optional</a></h1>
<p>Allow the pallet to validate some unsigned transaction:</p>
<p>Item is defined as:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">validate_unsigned</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">ValidateUnsigned</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
	<span class="comment">// ... regular trait implementation</span>
}</pre></div>
<p>I.e. a trait implementation with bound <code>T: Config</code>, of trait <code>ValidateUnsigned</code> for type
<code>Pallet&lt;T&gt;</code>, and some optional where clause.</p>
<p>NOTE: There is also <code>sp_runtime::traits::SignedExtension</code> that can be used to add some specific
logic for transaction validation.</p>
<h3 id="macro-expansion-12" class="section-header"><a href="#macro-expansion-12">Macro expansion</a></h3>
<p>Macro make currenlty no use of this information, but it might use this information in the
future to give information directly to construct_runtime.</p>
<h1 id="origin-palletorigin-optional" class="section-header"><a href="#origin-palletorigin-optional">Origin: <code>#[pallet::origin]</code> optional</a></h1>
<p>Allow to define some origin for the pallet.</p>
<p>Item must be either a type alias or an enum or a struct. It needs to be public.</p>
<p>E.g.:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">origin</span>]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Origin</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span>(<span class="ident">T</span>)<span class="op">&gt;</span>);</pre></div>
<p><strong>WARNING</strong>: modifying origin changes the outer runtime origin. This outer runtime origin can
be stored on-chain (e.g. in pallet-scheduler), thus any change must be done with care as it
might require some migration.</p>
<p>NOTE: for instantiable pallet, origin must be generic over T and I.</p>
<h1 id="general-notes-on-instantiable-pallet" class="section-header"><a href="#general-notes-on-instantiable-pallet">General notes on instantiable pallet</a></h1>
<p>An instantiable pallet is one where Config is generic, i.e. <code>Config&lt;I&gt;</code>. This allow runtime to
implement multiple instance of the pallet, by using different type for the generic.
This is the sole purpose of the generic <code>I</code>.
But because <code>PalletInfo</code> requires <code>Pallet</code> placeholder to be static it is important to bound
<code>'static</code> whenever <code>PalletInfo</code> can be used.
And in order to have instantiable pallet usable as a regular pallet without instance, it is
important to bound <code>= ()</code> on every types.</p>
<p>Thus impl bound look like <code>impl&lt;T: Config&lt;I&gt;, I: 'static&gt;</code>, and types look like
<code>SomeType&lt;T, I=()&gt;</code> or <code>SomeType&lt;T: Config&lt;I&gt;, I: 'static = ()&gt;</code>.</p>
<h1 id="example-for-pallet-without-instance" class="section-header"><a href="#example-for-pallet-without-instance">Example for pallet without instance.</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">frame_support</span>::<span class="ident">pallet</span>]</span>
<span class="comment">// NOTE: Example is name of the pallet, it will be used as unique identifier for storage</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">pallet</span> {
	<span class="kw">use</span> <span class="ident">frame_support</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>; <span class="comment">// Import various types used in pallet definition</span>
	<span class="kw">use</span> <span class="ident">frame_system</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>; <span class="comment">// OriginFor helper type for implementing dispatchables.</span>

	<span class="kw">type</span> <span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">T</span> <span class="kw">as</span> <span class="ident">Config</span><span class="op">&gt;</span>::<span class="ident">Balance</span>;

	<span class="comment">// Define the generic parameter of the pallet</span>
	<span class="comment">// The macro checks trait generics: is expected none or `I = ()`.</span>
	<span class="comment">// The macro parses `#[pallet::constant]` attributes: used to generate constant metadata,</span>
	<span class="comment">// expected syntax is `type $IDENT: Get&lt;$TYPE&gt;;`.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">config</span>]</span>
	<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">Config</span>: <span class="ident">frame_system</span>::<span class="ident">Config</span> {
		<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">constant</span>]</span> <span class="comment">// put the constant in metadata</span>
		<span class="kw">type</span> <span class="ident">MyGetParam</span>: <span class="ident">Get</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>;
		<span class="kw">type</span> <span class="ident">Balance</span>: <span class="ident">Parameter</span> <span class="op">+</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>;
		<span class="kw">type</span> <span class="ident">Event</span>: <span class="ident">From</span><span class="op">&lt;</span><span class="ident">Event</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ident">IsType</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">frame_system</span>::<span class="ident">Config</span><span class="op">&gt;</span>::<span class="ident">Event</span><span class="op">&gt;</span>;
	}

	<span class="comment">// Define some additional constant to put into the constant metadata.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">extra_constants</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="doccomment">/// Some description</span>
		<span class="kw">fn</span> <span class="ident">exra_constant_name</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u128</span> { <span class="number">4u128</span> }
	}

	<span class="comment">// Define the pallet struct placeholder, various pallet function are implemented on it.</span>
	<span class="comment">// The macro checks struct generics: is expected `T` or `T, I = DefaultInstance`</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">pallet</span>]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generate_store</span>(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait</span> <span class="ident">Store</span>)]</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

	<span class="comment">// Implement on the pallet hooks on pallet.</span>
	<span class="comment">// The macro checks:</span>
	<span class="comment">// * trait is `Hooks` (imported from pallet_prelude)</span>
	<span class="comment">// * struct is `Pallet&lt;T&gt;` or `Pallet&lt;T, I&gt;`</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">hooks</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">Hooks</span><span class="op">&lt;</span><span class="ident">BlockNumberFor</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
	}

	<span class="comment">// Declare Call struct and implement dispatchables.</span>
	<span class="comment">//</span>
	<span class="comment">// WARNING: Each parameter used in functions must implement: Clone, Debug, Eq, PartialEq,</span>
	<span class="comment">// Codec.</span>
	<span class="comment">//</span>
	<span class="comment">// The macro checks:</span>
	<span class="comment">// * pallet is `Pallet&lt;T&gt;` or `Pallet&lt;T, I&gt;`</span>
	<span class="comment">// * trait is `Call`</span>
	<span class="comment">// * each dispatchable functions first argument is `origin: OriginFor&lt;T&gt;` (OriginFor is</span>
	<span class="comment">//   imported from frame_system.</span>
	<span class="comment">//</span>
	<span class="comment">// The macro parse `#[pallet::compact]` attributes, function parameter with this attribute</span>
	<span class="comment">// will be encoded/decoded using compact codec in implementation of codec for the enum</span>
	<span class="comment">// `Call`.</span>
	<span class="comment">//</span>
	<span class="comment">// The macro generate the enum `Call` with a variant for each dispatchable and implements</span>
	<span class="comment">// codec, Eq, PartialEq, Clone and Debug.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">call</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="doccomment">/// Doc comment put in metadata</span>
		<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">weight</span>(<span class="number">0</span>)]</span> <span class="comment">// Defines weight for call (function parameters are in scope)</span>
		<span class="kw">fn</span> <span class="ident">toto</span>(
			<span class="ident">origin</span>: <span class="ident">OriginFor</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
			<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">compact</span>]</span> <span class="ident">_foo</span>: <span class="ident">u32</span>
		) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">DispatchResultWithPostInfo</span> {
			<span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">origin</span>;
			<span class="macro">unimplemented</span><span class="macro">!</span>();
		}
	}

	<span class="comment">// Declare pallet Error enum. (this is optional)</span>
	<span class="comment">// The macro checks enum generics and that each variant is unit.</span>
	<span class="comment">// The macro generate error metadata using doc comment on each variant.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">error</span>]</span>
	<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Error</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="doccomment">/// doc comment put into metadata</span>
		<span class="ident">InsufficientProposersBalance</span>,
	}

	<span class="comment">// Declare pallet Event enum. (this is optional)</span>
	<span class="comment">//</span>
	<span class="comment">// WARNING: Each type used in variants must implement: Clone, Debug, Eq, PartialEq, Codec.</span>
	<span class="comment">//</span>
	<span class="comment">// The macro generates event metadata, and derive Clone, Debug, Eq, PartialEq and Codec</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">event</span>]</span>
	<span class="comment">// Additional argument to specify the metadata to use for given type.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">metadata</span>(<span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Balance&quot;</span>, <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;Other&quot;</span>)]</span>
	<span class="comment">// Generate a funciton on Pallet to deposit an event.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generate_deposit</span>(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn</span> <span class="ident">deposit_event</span>)]</span>
	<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Event</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> {
		<span class="doccomment">/// doc comment put in metadata</span>
		<span class="comment">// `&lt;T as frame_system::Config&gt;::AccountId` is not defined in metadata list, the last</span>
		<span class="comment">// segment is put into metadata, i.e. `AccountId`</span>
		<span class="ident">Proposed</span>(<span class="op">&lt;</span><span class="ident">T</span> <span class="kw">as</span> <span class="ident">frame_system</span>::<span class="ident">Config</span><span class="op">&gt;</span>::<span class="ident">AccountId</span>),
		<span class="doccomment">/// doc</span>
		<span class="comment">// here metadata will be `Balance` as define in metadata list</span>
		<span class="ident">Spending</span>(<span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>),
		<span class="comment">// here metadata will be `Other` as define in metadata list</span>
		<span class="ident">Something</span>(<span class="ident">u32</span>),
	}

	<span class="comment">// Define a struct which implements `frame_support::traits::Get&lt;T::Balance&gt;`</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">type_value</span>]</span>
	<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn</span> <span class="ident">MyDefault</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">T</span>::<span class="ident">Balance</span> { <span class="number">3</span>.<span class="ident">into</span>() }

	<span class="comment">// Declare a storage, any amount of storage can be declared.</span>
	<span class="comment">//</span>
	<span class="comment">// Is expected either `StorageValue`, `StorageMap` or `StorageDoubleMap`.</span>
	<span class="comment">// The macro generates for struct `$identP` (for storage of name `$ident`) and implement</span>
	<span class="comment">// storage instance on it.</span>
	<span class="comment">// The macro macro expand the metadata for the storage with the type used:</span>
	<span class="comment">// * For storage value the type for value will be copied into metadata</span>
	<span class="comment">// * For storage map the type for value and the type for key will be copied into metadata</span>
	<span class="comment">// * For storage double map the type for value, key1, and key2 will be copied into</span>
	<span class="comment">//   metadata.</span>
	<span class="comment">//</span>
	<span class="comment">// NOTE: for storage hasher, the type is not copied because storage hasher trait already</span>
	<span class="comment">// implements metadata. Thus generic storage hasher is supported.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
	<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type</span> <span class="ident">MyStorageValue</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="op">=</span>
		<span class="ident">StorageValue</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">T</span>::<span class="ident">Balance</span>, <span class="ident">ValueQuery</span>, <span class="ident">MyDefault</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>;

	<span class="comment">// Another declaration</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">getter</span>(<span class="kw">fn</span> <span class="ident">my_storage</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type</span> <span class="ident">MyStorage</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">StorageMap</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">Blake2_128Concat</span>, <span class="ident">u32</span>, <span class="ident">u32</span><span class="op">&gt;</span>;

	<span class="comment">// Declare genesis config. (This is optional)</span>
	<span class="comment">//</span>
	<span class="comment">// The macro accept either type alias or struct or enum, it checks generics are consistent.</span>
	<span class="comment">//</span>
	<span class="comment">// Type must implement `Default` traits</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_config</span>]</span>
	<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">GenesisConfig</span> {
		<span class="ident">_myfield</span>: <span class="ident">u32</span>,
	}

	<span class="comment">// Declare genesis builder. (This is need only if GenesisConfig is declared)</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_build</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">GenesisBuild</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">GenesisConfig</span> {
		<span class="kw">fn</span> <span class="ident">build</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {}
	}

	<span class="comment">// Declare a pallet origin. (this is optional)</span>
	<span class="comment">//</span>
	<span class="comment">// The macro accept type alias or struct or enum, it checks generics are consistent.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">origin</span>]</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Origin</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);

	<span class="comment">// Declare validate_unsigned implementation.</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">validate_unsigned</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">ValidateUnsigned</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="kw">type</span> <span class="ident">Call</span> <span class="op">=</span> <span class="ident">Call</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>;
		<span class="kw">fn</span> <span class="ident">validate_unsigned</span>(
			<span class="ident">source</span>: <span class="ident">TransactionSource</span>,
			<span class="ident">call</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Call</span>
		) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TransactionValidity</span> {
			<span class="prelude-val">Err</span>(<span class="ident">TransactionValidityError</span>::<span class="ident">Invalid</span>(<span class="ident">InvalidTransaction</span>::<span class="ident">Call</span>))
		}
	}

	<span class="comment">// Declare inherent provider for pallet. (this is optional)</span>
	<span class="comment">//</span>
	<span class="comment">// The macro checks pallet is `Pallet&lt;T&gt;` or `Pallet&lt;T, I&gt;` and trait is `ProvideInherent`</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">inherent</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">ProvideInherent</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="kw">type</span> <span class="ident">Call</span> <span class="op">=</span> <span class="ident">Call</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>;
		<span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">InherentError</span>;

		<span class="kw">const</span> <span class="ident">INHERENT_IDENTIFIER</span>: <span class="ident">InherentIdentifier</span> <span class="op">=</span> <span class="ident">INHERENT_IDENTIFIER</span>;

		<span class="kw">fn</span> <span class="ident">create_inherent</span>(<span class="ident">_data</span>: <span class="kw-2">&amp;</span><span class="ident">InherentData</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Call</span><span class="op">&gt;</span> {
			<span class="macro">unimplemented</span><span class="macro">!</span>();
		}
	}

	<span class="comment">// Regular rust code needed for implementing ProvideInherent trait</span>

	<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">codec</span>::<span class="ident">Encode</span>, <span class="ident">sp_runtime</span>::<span class="ident">RuntimeDebug</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>, <span class="ident">derive</span>(<span class="ident">codec</span>::<span class="ident">Decode</span>))]</span>
	<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">InherentError</span> {
	}

	<span class="kw">impl</span> <span class="ident">sp_inherents</span>::<span class="ident">IsFatalError</span> <span class="kw">for</span> <span class="ident">InherentError</span> {
		<span class="kw">fn</span> <span class="ident">is_fatal_error</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
			<span class="macro">unimplemented</span><span class="macro">!</span>();
		}
	}

	<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">INHERENT_IDENTIFIER</span>: <span class="ident">sp_inherents</span>::<span class="ident">InherentIdentifier</span> <span class="op">=</span> <span class="kw-2">*</span><span class="string">b&quot;testpall&quot;</span>;
}</pre></div>
<h1 id="example-for-pallet-with-instance" class="section-header"><a href="#example-for-pallet-with-instance">Example for pallet with instance.</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">frame_support</span>::<span class="ident">pallet</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">pallet</span> {
	<span class="kw">use</span> <span class="ident">frame_support</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="ident">frame_system</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>;

	<span class="kw">type</span> <span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span> <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">T</span> <span class="kw">as</span> <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">Balance</span>;

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">config</span>]</span>
	<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="lifetime">&#39;static</span> <span class="op">=</span> ()<span class="op">&gt;</span>: <span class="ident">frame_system</span>::<span class="ident">Config</span> {
		<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">constant</span>]</span>
		<span class="kw">type</span> <span class="ident">MyGetParam</span>: <span class="ident">Get</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>;
		<span class="kw">type</span> <span class="ident">Balance</span>: <span class="ident">Parameter</span> <span class="op">+</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>;
		<span class="kw">type</span> <span class="ident">Event</span>: <span class="ident">From</span><span class="op">&lt;</span><span class="ident">Event</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident">I</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ident">IsType</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">frame_system</span>::<span class="ident">Config</span><span class="op">&gt;</span>::<span class="ident">Event</span><span class="op">&gt;</span>;
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">extra_constants</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span> {
		<span class="doccomment">/// Some description</span>
		<span class="kw">fn</span> <span class="ident">exra_constant_name</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u128</span> { <span class="number">4u128</span> }
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">pallet</span>]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generate_store</span>(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">trait</span> <span class="ident">Store</span>)]</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span> <span class="op">=</span> ()<span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span>(<span class="ident">T</span>, <span class="ident">I</span>)<span class="op">&gt;</span>);

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">hooks</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">Hooks</span><span class="op">&lt;</span><span class="ident">BlockNumberFor</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span> {
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">call</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span> {
		<span class="doccomment">/// Doc comment put in metadata</span>
		<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">weight</span>(<span class="number">0</span>)]</span>
		<span class="kw">fn</span> <span class="ident">toto</span>(<span class="ident">origin</span>: <span class="ident">OriginFor</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">compact</span>]</span> <span class="ident">_foo</span>: <span class="ident">u32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">DispatchResultWithPostInfo</span> {
			<span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">origin</span>;
			<span class="macro">unimplemented</span><span class="macro">!</span>();
		}
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">error</span>]</span>
	<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Error</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span> <span class="op">=</span> ()<span class="op">&gt;</span> {
		<span class="doccomment">/// doc comment put into metadata</span>
		<span class="ident">InsufficientProposersBalance</span>,
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">event</span>]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">metadata</span>(<span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Balance&quot;</span>, <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;Other&quot;</span>)]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generate_deposit</span>(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn</span> <span class="ident">deposit_event</span>)]</span>
	<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Event</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span> <span class="op">=</span> ()<span class="op">&gt;</span> {
		<span class="doccomment">/// doc comment put in metadata</span>
		<span class="ident">Proposed</span>(<span class="op">&lt;</span><span class="ident">T</span> <span class="kw">as</span> <span class="ident">frame_system</span>::<span class="ident">Config</span><span class="op">&gt;</span>::<span class="ident">AccountId</span>),
		<span class="doccomment">/// doc</span>
		<span class="ident">Spending</span>(<span class="ident">BalanceOf</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span>),
		<span class="ident">Something</span>(<span class="ident">u32</span>),
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">type_value</span>]</span>
	<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn</span> <span class="ident">MyDefault</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">T</span>::<span class="ident">Balance</span> { <span class="number">3</span>.<span class="ident">into</span>() }

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
	<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type</span> <span class="ident">MyStorageValue</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span> <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">=</span>
		<span class="ident">StorageValue</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">T</span>::<span class="ident">Balance</span>, <span class="ident">ValueQuery</span>, <span class="ident">MyDefault</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span><span class="op">&gt;</span>;

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">getter</span>(<span class="kw">fn</span> <span class="ident">my_storage</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type</span> <span class="ident">MyStorage</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span> <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">=</span>
		<span class="ident">StorageMap</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">Blake2_128Concat</span>, <span class="ident">u32</span>, <span class="ident">u32</span><span class="op">&gt;</span>;

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_config</span>]</span>
	<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">GenesisConfig</span> {
		<span class="ident">_myfield</span>: <span class="ident">u32</span>,
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_build</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">GenesisBuild</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">GenesisConfig</span> {
		<span class="kw">fn</span> <span class="ident">build</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {}
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">origin</span>]</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Origin</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span> <span class="op">=</span> ()<span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span>(<span class="ident">T</span>, <span class="ident">I</span>)<span class="op">&gt;</span>);

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">validate_unsigned</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">ValidateUnsigned</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span> {
		<span class="kw">type</span> <span class="ident">Call</span> <span class="op">=</span> <span class="ident">Call</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span>;
		<span class="kw">fn</span> <span class="ident">validate_unsigned</span>(
			<span class="ident">source</span>: <span class="ident">TransactionSource</span>,
			<span class="ident">call</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Call</span>
		) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TransactionValidity</span> {
			<span class="prelude-val">Err</span>(<span class="ident">TransactionValidityError</span>::<span class="ident">Invalid</span>(<span class="ident">InvalidTransaction</span>::<span class="ident">Call</span>))
		}
	}

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">inherent</span>]</span>
	<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&lt;</span><span class="ident">I</span><span class="op">&gt;</span>, <span class="ident">I</span>: <span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="ident">ProvideInherent</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span> {
		<span class="kw">type</span> <span class="ident">Call</span> <span class="op">=</span> <span class="ident">Call</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">I</span><span class="op">&gt;</span>;
		<span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">InherentError</span>;

		<span class="kw">const</span> <span class="ident">INHERENT_IDENTIFIER</span>: <span class="ident">InherentIdentifier</span> <span class="op">=</span> <span class="ident">INHERENT_IDENTIFIER</span>;

		<span class="kw">fn</span> <span class="ident">create_inherent</span>(<span class="ident">_data</span>: <span class="kw-2">&amp;</span><span class="ident">InherentData</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Call</span><span class="op">&gt;</span> {
			<span class="macro">unimplemented</span><span class="macro">!</span>();
		}
	}

	<span class="comment">// Regular rust code needed for implementing ProvideInherent trait</span>

	<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">codec</span>::<span class="ident">Encode</span>, <span class="ident">sp_runtime</span>::<span class="ident">RuntimeDebug</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>, <span class="ident">derive</span>(<span class="ident">codec</span>::<span class="ident">Decode</span>))]</span>
	<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">InherentError</span> {
	}

	<span class="kw">impl</span> <span class="ident">sp_inherents</span>::<span class="ident">IsFatalError</span> <span class="kw">for</span> <span class="ident">InherentError</span> {
		<span class="kw">fn</span> <span class="ident">is_fatal_error</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
			<span class="macro">unimplemented</span><span class="macro">!</span>();
		}
	}

	<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">INHERENT_IDENTIFIER</span>: <span class="ident">sp_inherents</span>::<span class="ident">InherentIdentifier</span> <span class="op">=</span> <span class="kw-2">*</span><span class="string">b&quot;testpall&quot;</span>;
}</pre></div>
<h2 id="upgrade-guidelines" class="section-header"><a href="#upgrade-guidelines">Upgrade guidelines:</a></h2>
<ol>
<li>
<p>make crate compiling: rename usage of frame_system::Trait to frame_system::Config.</p>
</li>
<li>
<p>export metadata of the pallet for later checks</p>
</li>
<li>
<p>generate the template upgrade for the pallet provided by decl_storage with environment
variable <code>PRINT_PALLET_UPGRADE</code>: <code>PRINT_PALLET_UPGRADE=1 cargo check -p my_pallet</code>
This template can be used as information it contains all information for storages, genesis
config and genesis build.</p>
</li>
<li>
<p>reorganize pallet to have trait Trait, decl_* macros, ValidateUnsigned, ProvideInherent,
Origin all together in one file. suggested order:</p>
<ul>
<li>trait,</li>
<li>decl_module,</li>
<li>decl_event,</li>
<li>decl_error,</li>
<li>decl_storage,</li>
<li>origin,</li>
<li>validate_unsigned,</li>
<li>provide_inherent,
so far it should compile and all be correct.</li>
</ul>
</li>
<li>
<p>start writing new pallet module</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">pallet</span>::<span class="kw-2">*</span>;
<span class="attribute">#[<span class="ident">frame_support</span>::<span class="ident">pallet</span>]</span>
<span class="kw">mod</span> <span class="ident">pallet</span> {
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">frame_support</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>;
	<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">frame_system</span>::<span class="ident">pallet_prelude</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;

	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">pallet</span>]</span>
	<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">generete</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">visibility_of_trait_store</span> <span class="kw">trait</span> <span class="ident">Store</span>)]</span>
	<span class="comment">// NOTE: if the visibility of trait store is private but you want to make it available</span>
	<span class="comment">// in super, then use `pub(super)` or `pub(crate)` to make it available in crate.</span>
	<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>);
	<span class="comment">// pub struct Pallet&lt;T, I = ()&gt;(PhantomData&lt;T&gt;); // for instantiable pallet</span>
}</pre></div>
</li>
<li>
<p><strong>migrate trait</strong>: move trait into the module with</p>
<ul>
<li>rename <code>Trait</code> to <code>Config</code></li>
<li>all const in decl_module to <code>#[pallet::constant]</code></li>
</ul>
</li>
<li>
<p><strong>migrate decl_module</strong>: write:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">hooks</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Trait</span><span class="op">&gt;</span> <span class="ident">Hooks</span> <span class="kw">for</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
}</pre></div>
<p>and write inside on_initialize/on_finalize/on_runtime_upgrade/offchain_worker/integrity_test</p>
<p>then write:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">call</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Trait</span><span class="op">&gt;</span> <span class="ident">Pallet</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
}</pre></div>
<p>and write inside all the call in decl_module with a few changes in the signature:</p>
<ul>
<li>origin must now be written completly, e.g. <code>origin: OriginFor&lt;T&gt;</code></li>
<li>result type must be <code>DispatchResultWithPostInfo</code>, you need to write it and also you might
need to put <code>Ok(().into())</code> at the end or the function.</li>
<li><code>#[compact]</code> must now be written <code>#[pallet::compact]</code></li>
<li><code>#[weight = ..]</code> must now be written <code>#[pallet::weight(..)]</code></li>
</ul>
</li>
<li>
<p><strong>migrate event</strong>:
rewrite as a simple enum under with the attribute <code>#[pallet::event]</code>,
use <code>#[pallet::generate_deposit($vis fn deposit_event)]</code> to generate deposit_event,
use <code>#[pallet::metadata(...)]</code> to configure the metadata for types in order not to break them.</p>
</li>
<li>
<p><strong>migrate error</strong>: just rewrite it with attribute <code>#[pallet::error]</code>.</p>
</li>
<li>
<p><strong>migrate storage</strong>:
decl_storage provide an upgrade template (see 3.). All storages, genesis config, genesis
build and default implementation of genesis config can be taken from it directly.</p>
<p>Otherwise here is the manual process:</p>
<p>first migrate the genesis logic. write:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_config</span>]</span>
<span class="kw">struct</span> <span class="ident">GenesisConfig</span> {
	<span class="comment">// fields of add_extra_genesis</span>
}
<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">GenesisConfig</span> {
	<span class="comment">// type default or default provided for fields</span>
}
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">genesis_build</span>]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Config</span><span class="op">&gt;</span> <span class="ident">GenesisBuild</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">GenesisConfig</span> {
<span class="comment">// impl&lt;T: Config, I: &#39;static&gt; GenesisBuild&lt;T, I&gt; for GenesisConfig { for instantiable pallet</span>
	<span class="kw">fn</span> <span class="ident">build</span>() {
		<span class="comment">// The add_extra_genesis build logic</span>
	}
}</pre></div>
<p>for each storages, if it contains config(..) then add a fields, and make its default to the
value in <code>= ..;</code> or the type default if none, if it contains no build then also add the
logic to build the value.
for each storages if it contains build(..) then add the logic to genesis_build.</p>
<p>NOTE: in decl_storage: is executed first the individual config and build and at the end the
add_extra_genesis build</p>
<p>Once this is done you can migrate storage individually, a few notes:</p>
<ul>
<li>for private storage use <code>pub(crate) type </code> or <code>pub(super) type</code> or nothing,</li>
<li>for storage with <code>get(fn ..)</code> use <code>#[pallet::getter(fn ...)]</code></li>
<li>for storage with value being <code>Option&lt;$something&gt;</code> make generic <code>Value</code> being <code>$something</code>
and generic <code>QueryKind</code> being <code>OptionQuery</code> (note: this is default). Otherwise make
<code>Value</code> the complete value type and <code>QueryKind</code> being <code>ValueQuery</code>.</li>
<li>for storage with default value: <code>= $expr;</code> provide some specific OnEmpty generic. To do so
use of <code>#[pallet::type_value]</code> to generate the wanted struct to put.
example: <code>MyStorage: u32 = 3u32</code> would be written:
<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">type_value</span>]</span> <span class="kw">fn</span> <span class="ident">MyStorageOnEmpty</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u32</span> { <span class="number">3u32</span> }
<span class="attribute">#[<span class="ident">pallet</span>::<span class="ident">storage</span>]</span>
<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">type</span> <span class="ident">MyStorage</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">StorageValue</span><span class="op">&lt;</span><span class="ident">u32</span>, <span class="ident">ValueQuery</span>, <span class="ident">MyStorageOnEmpty</span><span class="op">&gt;</span>;</pre></div>
</li>
</ul>
<p>NOTE: decl_storage also generates functions <code>assimilate_storage</code> and <code>build_storage</code>
directly on GenesisConfig, those are sometimes used in tests. In order not to break they
can be implemented manually, just implement those functions by calling <code>GenesisBuild</code>
implementation.</p>
</li>
<li>
<p><strong>migrate origin</strong>: just move the origin to the pallet module under <code>#[pallet::origin]</code></p>
</li>
<li>
<p><strong>migrate validate_unsigned</strong>: just move the ValidateUnsigned implementation to the pallet
module under <code>#[pallet::validate_unsigned]</code></p>
</li>
<li>
<p><strong>migrate provide_inherent</strong>: just move the ValidateUnsigned implementation to the pallet
module under <code>#[pallet::provide_inherent]</code></p>
</li>
<li>
<p>rename the usage of Module to Pallet and the usage of Config to Trait inside the crate.</p>
</li>
<li>
<p>migration is done, now double check migration with the checking migration guidelines.</p>
</li>
</ol>
<h2 id="checking-upgrade-guidelines" class="section-header"><a href="#checking-upgrade-guidelines">Checking upgrade guidelines:</a></h2>
<ul>
<li>compare metadata. This checks for:
<ul>
<li>call, names, signature, doc</li>
<li>event names, docs</li>
<li>error names, docs</li>
<li>storage names, hasher, prefixes, default value</li>
<li>error , error, constant,</li>
</ul>
</li>
<li>manually check that:
<ul>
<li>Origin is moved inside macro unser <code>#[pallet::origin]</code> if it exists</li>
<li>ValidateUnsigned is moved inside macro under <code>#[pallet::validate_unsigned)]</code> if it exists</li>
<li>ProvideInherent is moved inside macro under <code>#[pallet::inherent)]</code> if it exists</li>
<li>on_initialize/on_finalize/on_runtime_upgrade/offchain_worker are moved to Hooks
implementation</li>
<li>storages with <code>config(..)</code> are converted to genesis_config field, and their default is
<code>= $expr;</code> if the storage have default value</li>
<li>storages with <code>build($expr)</code> or <code>config(..)</code> are built in genesis_build</li>
<li>add_extra_genesis fields are converted to genesis_config field with their correct default
if specified</li>
<li>add_extra_genesis build is written into genesis_build</li>
</ul>
</li>
<li>storages now use PalletInfo for module_prefix instead of the one given to decl_storage:
Thus any use of this pallet in <code>construct_runtime!</code> should be careful to update name in
order not to break storage or to upgrade storage (moreover for instantiable pallet).
If pallet is published, make sure to warn about this breaking change.
Macro to define a pallet. Docs are at <code>frame_support::pallet</code>.</li>
</ul>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "frame_support";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>